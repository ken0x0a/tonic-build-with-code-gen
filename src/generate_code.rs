use super::{Method, Service};
use crate::{generate_doc_comments, naive_snake_case, util};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

/// Generate boilerplate code for gRPC server
///
/// This takes some `Service` and will generate a `TokenStream` that contains
/// a public module with the generated client.
pub fn generate<T: Service>(service: &T, proto_path: &str) {
  generate_service_file(service, proto_path);
  generate_file_for_each_method(service, proto_path);

  // format generated files
  #[cfg(feature = "rustfmt")]
  {
    let source_dir = format!("{}/src", std::env::current_dir().unwrap().to_str().unwrap());
    super::fmt(&source_dir);
  }
}
fn generate_service_file<T: Service>(service: &T, proto_path: &str) {
  let stream = generate_service(service, proto_path);

  util::write_stream_to_file_with_header(stream, "src/service.rs", None)
    .expect("failed to write result to file");
}

fn generate_service<T: Service>(service: &T, proto_path: &str) -> TokenStream {
  let service_name_str = naive_snake_case(service.name());
  let service_name = quote::format_ident!("{}", service.name());
  let service_server_name = quote::format_ident!("{}_server", naive_snake_case(service.name()));
  let proto_mod_name = quote::format_ident!("{}_proto", naive_snake_case(service.name()));
  let service_ident = quote::format_ident!("{}Service", service.name());
  let service_doc = generate_doc_comments(service.comment());
  let service_methods = generate_methods(service, proto_path);

  let stream = quote! {
    // use tonic::{Request, Response, Status};

    use #proto_mod_name::#service_server_name::Auth;
    use #proto_mod_name::{AuthResponse, RegisterPayload};

    use super::action;

    pub mod #proto_mod_name {
      tonic::include_proto!(#service_name_str);
    }

    // Generated client implementations.
    //
    #service_doc
    #[derive(Default)]
    pub struct #service_ident {}

    #[tonic::async_trait]
    impl #service_name for #service_ident {
      #service_methods
    }
  };

  stream
}

fn generate_methods<T: Service>(service: &T, proto_path: &str) -> TokenStream {
  let mut stream = TokenStream::new();

  for method in service.methods() {
    stream.extend(generate_doc_comments(method.comment()));

    let method = generate_each_method_for_service(method, proto_path);

    stream.extend(method);
  }

  stream
}

fn generate_each_method_for_service<T: Method>(method: &T, proto_path: &str) -> TokenStream {
  // let codec_name = syn::parse_str::<syn::Path>(T::CODEC_PATH).unwrap();
  let ident = format_ident!("{}", method.name());

  let (request, response) = get_req_res_type(method, proto_path);

  quote! {
    async fn #ident(
      &self,
      request: tonic::Request<#request>,
    ) -> ::std::result::Result<tonic::Response<#response>, tonic::Status> {
      action::#ident::handler(request).await
    }
  }
}

fn get_req_res_type<T: Method>(
  method: &T,
  proto_path: &str,
) -> (quote::__private::Ident, quote::__private::Ident) {
  let (request, response) = method.request_response_name(proto_path);
  let v = format!("{}", request);
  // assert_eq!("RegisterPayload", v);
  let v: Vec<&str> = v.split(" :: ").collect();
  let request_type = format_ident!("{}", v[1]);

  let v = format!("{}", response);
  let v: Vec<&str> = v.split(" :: ").collect();
  let response_type = format_ident!("{}", v[1]);

  (request_type, response_type)
}

// ###########################################
// ############  for each method  ############
// ###########################################
fn generate_file_for_each_method<T: Service>(service: &T, proto_path: &str) {
  let mut stream_for_mod = TokenStream::new();

  let header = "// This file is generated by \"proto-gen-code\"
  // You can refresh boilerplate by removing this file\n\n";

  for method in service.methods() {
    let method_name = format_ident!("{}", method.name());
    stream_for_mod.extend(quote! {
      pub mod #method_name;
    });

    let mut stream = TokenStream::new();

    stream.extend(generate_doc_comments(method.comment()));

    let method_stream = generate_method_handler(service, method, proto_path);

    stream.extend(method_stream);

    util::write_stream_to_file_with_header_if_not_exist(
      stream,
      &format!("src/action/{}.rs", method.name()),
      Some(&header),
    )
    .expect("failed to write result to file");
  }

  util::write_stream_to_file_with_header(stream_for_mod, "src/action.rs", None)
    .expect("failed to write result to file");
}

fn generate_method_handler<S: Service, T: Method>(
  service: &S,
  method: &T,
  proto_path: &str,
) -> TokenStream {
  // let service_name = quote::format_ident!("{}", service.name());
  let proto_mod_name = quote::format_ident!("{}_proto", naive_snake_case(service.name()));

  // let codec_name = syn::parse_str::<syn::Path>(T::CODEC_PATH).unwrap();
  // let ident = format_ident!("{}", method.name());
  let (request, response) = get_req_res_type(method, proto_path);

  quote! {
    use tonic::{Request, Response, Status};
    use crate::#proto_mod_name::{#request, #response};

    pub async fn handler(
      request: Request<#request>,
    ) -> Result<Response<#response>, Status> {
      println!("Request from {:?}", request.remote_addr());
      println!("Metadata => {:?}", request.metadata());

      let message = request.into_inner();
      let reply = #response {
        message: format!("Hello {}!", message.name),
        field_name: String::from(""),
        // ..
      };
      Ok(Response::new(reply))
    }
  }
}
